#+Title: Twisted Mixing
#+Author: Laurens Van Houtven
#+Email: @lvh

#+OPTIONS: toc:nil reveal_rolling_links:nil
#+REVEAL_TRANS: linear
#+REVEAL_THEME: lvh

* Introduction
** About me
   Hi, I'm =lvh=.

   I hack on and with Twisted.

** Rackspace

   #+ATTR_HTML: :style border:none
   [[./media/rackspace.svg]]

** About this talk

   #+ATTR_REVEAL: :frag roll-in
   * Twisted code ↔ other code
   * Show that you probably *can* use Twisted
      * (Not so much that you *should* use Twisted)
   * Overview

** Why should you care?

   #+ATTR_REVEAL: :frag roll-in
   * Twisted has some cool stuff in and around it
     #+ATTR_REVEAL: :frag roll-in
     * IRC, SMTP, DNS, SSH, WebSockets...
     * Running multiple things in one process
     * Timed events, sane process and thread management
     * Protocol and transport abstractions
     * ...
   * Twisted vs other stuff: good at different things
     #+ATTR_REVEAL: :frag roll-in
     * Many connections, particularly if relatively silent
        * Incoming, e.g. a chat server
        * Outgoing, e.g. a scraper
     #+ATTR_REVEAL: :frag roll-in
     * Cooperate with existing event loops
       * GUIs
       * gevent

** Prerequisites

   #+ATTR_REVEAL: :frag roll-in
   * Ideally, just Python
   * Having played with Twisted probably helps
   * I will explain important concepts briefly
      * Please feel free to interrupt if I forget to

* Introducing Twisted

** Reactor

   #+ATTR_REVEAL: :frag roll-in
   * Object
     * Allows registration of new events
     * Waits for those events
     * Dispatches them when they occur
   * Internally an event loop
     * Except for test reactors e.g. =Clock=
     * Backed by some event mechanism

** Reactor interfaces

   Usually you call higher-level APIs!

   #+ATTR_REVEAL: :frag roll-in
   * =IReactorBase=: =run=, =stop=...
   * =IReactorTime=: =callLater=...
   * =IReactorProcess=: =spawnProcess=
   * =IReactorThreads=: =callInThread=, =callFromThread=, ...
   * =IReactor(TCP|UDP|SSL|Multicast)=
   * =IReactor(UNIX|UNIXDatagram|Socket)=
   * =IReactorFDSet=: =(add|remove)(Reader|Writer)=, ...

** Deferred

   An object you get *now*,

   gets you result or failure *later*

** Why deferreds?

   #+ATTR_REVEAL: :frag roll-in
   * Many operations take time: *can't* get a result right now
   * Blocking API
     * Evaluate or raise some point in the future
     * Thread can't do anything else in the mean while
   * Deferred API
     * Get an object representing the future result *now*
     * Actually give result (or failure) when it's available
     * Thread is free to do something else

** Deferred vs blocking API

   Blocking read:
   #+BEGIN_SRC python
   try:
       result = blocking_read()
       on_result(result)
   except SomeError as e:
       on_failure(e)
   #+END_SRC

   Deferred read:
   #+BEGIN_SRC python
   d = async_read()
   d.addCallbacks(on_result, on_failure)
   #+END_SRC

** Inline callbacks vs blocking API

   Blocking read:
   #+BEGIN_SRC python
   try:
       result = blocking_read()
       on_result(result)
   except SomeError as e:
       on_failure(e)
   #+END_SRC

   =inlineCallbacks=: Deferreds + sugar
   #+BEGIN_SRC python
   try:
       result = yield async_read()
       on_result(result)
   except SomeError as e:
       on_failure(e)
   #+END_SRC

* Twisted and your app

** Is there even a problem?

   Maybe it's trivial to get started!

** SOA

   #+ATTR_REVEAL: :frag roll-in
   * Service Oriented Architecture
     * "Loosely coupled things that talk to each other"

   * Written in Gevent? Twisted? COBOL? Who cares!?
   * Work with Twisted, without touching existing code

** WSGI

   #+ATTR_REVEAL: :frag roll-in
   * How many of you have a WSGI application?
   * Twisted is a WSGI server:
     #+BEGIN_SRC sh
     twistd web --wsgi=location.of.wsgi.app
     #+END_SRC
   * Not a toy web server, can be used in production
     * =twistedmatrix.com=: Trac, Buildbot...
   * Twisted does CGI too, but I hope *you* don't

** Porting your app to Twisted

   #+ATTR_REVEAL: :frag roll-in
   * No, it's not trivial
     * ... but cost is almost always overestimated
   * Clean, tested code helps
     * Keep verifying behavior
     * Tested code tends to be decoupled
   * If it's near impossible, it's probably a code smell

** Writing code that works on both

   * Not trivial, not hard either
   * Example: =praekelt/vumi=
   * TODO: more examples

** Demo

   * Flask app, served by =t.w.wsgi=
   * Real-time chat, with =txsockjs=

   [[file:media/twistyflask-tox-run.mp4][Test run]], [[file:media/twistyflask-demo.mp4][demo]]

** Demo notes

   * =Klein=: Flask-like basic API, except Twisted by default
   * Having data come from two sources is kind of dumb
     * ... but I had to have Flask do something :)
   * Quality!
     * No authentication, users are who they say they are
       * Duplicate usernames allowed
     * Protocol does dispatching + behavior

* Blocking code in Twisted

** You can't block the reactor thread

   #+ATTR_REVEAL: :frag roll-in
   * Twisted is event-driven
       * Production reactors are just event loops
       * =select=, =epoll=, =kqueue=, IOCP, =libev(ent)=...
   * Reactor runs in a thread, calls everything else
       * One thing at a time, all in the same thread
       * Concurrency through asynchronous IO
   * Blocking the reactor thread means nothing else happens

** Blocking in a callback is bad!

   Blocking IO
   #+BEGIN_SRC python
   def _getDataAtURL(url):
       return requests.get(url).json() # BLOCKS!
   #+END_SRC

   Blocking computation
   #+BEGIN_SRC python
   def _compute(n):
       x = 2
       for _ in xrange(n): # BLOCKS! (for sufficiently large n)
           x *= x
       send_somewhere(x)
   #+END_SRC

** Can't block the reactor thread!

   Therefore, you have two options:

   1. Don't block
   2. Block another thread

** Don't block

   IO bound? Be asynchronous!

   CPU bound? Cooperate with the event loop!

** Asynchronous I/O version

   =treq=: =requests=-like, but asynchronous
   #+BEGIN_SRC python
   def _getDataAtURL(url):
       return treq.get(url).addCallback(treq.json_content) # async :)
   #+END_SRC

** Cooperative version

   =twisted.internet.task.coiterate= and friends

   #+BEGIN_SRC python
   def _compute(n):
       x = 2
       for _ in xrange(n):
           x *= x
           yield # Yields to the reactor :)
       send_somewhere(x)

   coiterate(_compute(n))
   #+END_SRC

** Don't block?

   Avoiding blocking isn't always possible

   #+ATTR_REVEAL: :frag roll-in
   * Blocking API
     * =DBAPI2=, ...
   * Sometimes in C code you can't or don't want to mess with
     * =scrypt=, ...
   * Sometimes at a kernel/syscall level
     * File IO, ...

** Block somewhere else
   Can't block the reactor thread → block a different one!

   #+ATTR_REVEAL: :frag roll-in
   * ... in the same process: =deferToThread=
     * often used by wrappers: =adbapi=, =txscrypt=...
   * ... in a child process: =spawnProcess= and friends
   * ... in a remote process: Ampoule, PB, Foolscap, RPC...

** deferToThread

   #+ATTR_REVEAL: :frag roll-in
   * Easiest way to make things magically not block
   * Deferred, like everything else
   * Shared mutable state is crazy annoying to get right
     #+ATTR_REVEAL: :frag roll-in
     * Passing in a ={}=: crude, awful hack
       * but Python guarantees =dict= operations are atomic...
     * Got shared mutable state?
       * Django is full of it
       * Python modules are shared mutable state, too
     * Consequence of threads, not =deferToThread=

* Twisted in blocking code

** New hotness!

   =itamarst/crochet=

** Setting it up

   =from crochet import setup; setup()=

   #+ATTR_REVEAL: :frag roll-in
   * Spawns a thread, runs the reactor in it
   * Idempotent
   * Makes =logging= magically work

** Using it

   #+ATTR_REVEAL: :frag roll-in
   * =@run_in_reactor=
     * Function runs in reactor thread, not calling thread
     * Results in an =EventualResult=
   * =EventualResult=?
     * Synchronous analog of =Deferred=
     * =wait(timeout=None)=
     * =cancel()=, =stash()=

** Example

    #+BEGIN_SRC python
    from twisted.web.client import getPage
    from crochet import setup, run_in_reactor
    setup()

    @run_in_reactor
    def download_page(url):
        return getPage(url)

    result = download_page("http://www.google.com")
    print result.wait()
    #+END_SRC

** Longer example: exchange rates

   * Twisted queries exchange rate every 30s
     * Runs in a separate thread using =crochet=
   * Flask app serves the latest exchange rate

   [[file:media/twistycrochet-demo.mp4][Demo]]

** How does it work? Twisted part

   #+BEGIN_SRC python
   class ExchangeRate(object):
       # ...

       @run_in_reactor
       def start(self):
           # in reactor thread because of decorator
           self._lc = LoopingCall(self._download)
           self._lc.start(30, now=True)

       def _download(self):
           # in reactor thread because of LoopingCall
           d = getPage(url)
           # ...
   #+END_SRC

   Twisted code looks like regular Twisted code!

   (But remember the =@run_in_reactor=)

** How does it work? Flask part

   #+BEGIN_SRC python
   @app.route('/')
   def index():
       # runs in whatever thread app.run() runs it in
       rate = EURUSD.latest_value()
       if rate is None:
           rate = "unavailable"
       return "EUR/USD rate: {0}.".format(rate)

   app.run()
   #+END_SRC

   Flask code looks like regular Flask code!

* Twisted in Gevent

** Water and fire, but it works

   =jyio/geventreactor=

** Setting it up

   =import geventreactor=

   =geventreactor.install()=

** "Blocking" code

   * Gevent-style "blocking", i.e.  automagic suspending
   #+ATTR_REVEAL: :frag roll-in
   * Supported in most places
     #+ATTR_REVEAL: :frag roll-in
     * Suspending the reactor greenlet: bad
     * Actually blocking anything: bad
     * Earlier =requests.get= example: probably okay

** Deferreds ↔ greenlets

  =r = waitForDeferred(d)=

  =d = waitForGreenlet(g)=

** Demo

   TODO

* Recap

** Twisted plays well with others

   #+ATTR_REVEAL: :frag roll-in
   * It supports many protocols
     * JSON-RPC, XML-RPC, HTTP/REST, AMP, whatever
     * It will serve your WSGI apps
   * It will work side by side with existing blocking code
   * It can have blocking code added to it later
   * It will cooperate with most existing event loops
     #+ATTR_REVEAL: :frag roll-in
     * Gevent, =libev(ent)=, CoreFoundation...
     * GUIs, like GTK, Qt...
     * ZeroMQ (but please don't use ZeroMQ)
     * ...
   * Many analogs for things you already know are available
     #+ATTR_REVEAL: :frag roll-in
     * =treq= is like =requests=
     * =klein= is like Flask
     * =cyclone= is Tornado on top of Twisted's reactor
     * ...

** Conclusion

   #+ATTR_REVEAL: :frag roll-in
   * If you want to use Twisted, you probably can
   * That doesn't mean it's a good idea
     #+ATTR_REVEAL: :frag roll-in
     * ... although it probably is ;-)

* Questions?
